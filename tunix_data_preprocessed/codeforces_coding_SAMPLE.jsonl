{"text": "<start_of_turn>user\nGiven an array of integers, find the maximum sum of a contiguous subarray.\n\nInput:\nThe first line contains an integer n (1 ≤ n ≤ 10^5) — the length of the array.\nThe second line contains n integers a₁, a₂, ..., aₙ (-10^9 ≤ aᵢ ≤ 10^9).\n\nOutput:\nPrint a single integer — the maximum sum.\n<end_of_turn>\n<start_of_turn>model\n<reasoning>\nThis is a classic maximum subarray sum problem (Kadane's algorithm).\n\nStep 1: Initialize max_sum to negative infinity and current_sum to 0.\nStep 2: Iterate through each element in the array.\nStep 3: Add the current element to current_sum.\nStep 4: Update max_sum if current_sum is greater.\nStep 5: If current_sum becomes negative, reset it to 0.\nStep 6: Return max_sum.\n\nTime complexity: O(n)\nSpace complexity: O(1)\n</reasoning>\n<answer>\n```python\nn = int(input())\narr = list(map(int, input().split()))\n\nmax_sum = float('-inf')\ncurrent_sum = 0\n\nfor num in arr:\n    current_sum += num\n    max_sum = max(max_sum, current_sum)\n    if current_sum < 0:\n        current_sum = 0\n\nprint(max_sum)\n```\n</answer>\n<end_of_turn>"}
{"text": "<start_of_turn>user\nCount the number of pairs (i, j) such that i < j and aᵢ + aⱼ = k, where k is given.\n\nInput:\nFirst line: n (array length) and k (target sum)\nSecond line: n integers\n\nOutput:\nNumber of valid pairs\n<end_of_turn>\n<start_of_turn>model\n<reasoning>\nWe can use a hash map to solve this efficiently:\n\n1. Create an empty hash map to store frequencies\n2. For each element x in the array:\n   - Check if (k - x) exists in the hash map\n   - If yes, add its frequency to the result\n   - Add x to the hash map (or increment its count)\n3. Return the count\n\nThis ensures we count each pair exactly once since we only look backward.\n</reasoning>\n<answer>\n```cpp\n#include <iostream>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n, k;\n    cin >> n >> k;\n    \n    unordered_map<int, int> freq;\n    long long count = 0;\n    \n    for (int i = 0; i < n; i++) {\n        int x;\n        cin >> x;\n        count += freq[k - x];\n        freq[x]++;\n    }\n    \n    cout << count << endl;\n    return 0;\n}\n```\n</answer>\n<end_of_turn>"}
